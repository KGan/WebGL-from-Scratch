<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>WebGL from Scratch</title>

<style type="text/css">

body {
    margin: 0;
    padding: 0;
}

</style>

<script id="vs-shader" type="x-shader/x-vertex">

attribute vec4 position;

void main(void) {
    gl_Position = position;
}

</script>

<script id="fs-shader" type="x-shader/x-fragment">

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D tex0;
uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;
uniform vec3 particles[32];
uniform vec2 lightDirection;

vec3 calculateDistortion(vec2 coord, vec3 particle)
{
    vec2 delta = vec2(coord.x-particle.x,coord.y-particle.y);
    float distance = length(delta);
    vec2 deltaNormal = delta/distance;
    float magnitude = clamp(particle.z,0.,1.);
    float fade = clamp(60./magnitude-distance,0.,1.);
    vec2 distortion = deltaNormal*sin(distance*.1-time*2.0)*magnitude*fade;
    return vec3(distortion, 0);
}

vec4 dodge(vec4 bottom, vec4 top)
{
    return vec4(bottom.xyz/(vec3(1.)-top.xyz),1.);
}

void main(void)
{
    vec2 coord = vec2(gl_FragCoord.x,resolution.y-gl_FragCoord.y);
    vec3 uv = vec3(coord.xy/resolution.xy,1);
    vec4 addColor = vec4(0);
    vec3 debug_uv = vec3(.5);

    for (int i = 0; i < 32; i++) {
        vec3 distortion = .5*calculateDistortion(coord, particles[i]);
        uv += distortion*.05;
        debug_uv += distortion;
        addColor += .5*vec4(lightDirection.x*distortion.x+lightDirection.y*distortion.y);
    }
    addColor = clamp(addColor,0.,1.);
    
    vec3 col = uv.z * texture2D(tex0,uv.xy).xyz;
    //gl_FragColor = vec4(debug_uv, 1.0);
    gl_FragColor = dodge(vec4(col,1.0),addColor);
}

</script>

<script type="text/javascript">

    window.timotuominen = { webgl: {} };

    timotuominen.webgl.FromScratchDemo = function (options) {
        options = options || {};
        var NUM_PARTICLE_COMPONENTS = 3;
        var PARTICLE_X = 0;
        var PARTICLE_Y = 1;
        var PARTICLE_LIFE = 2;
        var NUM_MAX_PARTICLES = 32;

        return {
            __proto__: new timotuominen.webgl.Runner(options),

            shader: null,
            vertexBuffer: null,
            texture: null,
            vertices: null,
            startTime: null,
            mousePos: null,
            particles: new Array(NUM_MAX_PARTICLES*NUM_PARTICLE_COMPONENTS),

            initialize: function () {
                this.__proto__.initialize.apply(this);

                var shaderUtils = timotuominen.webgl.shaderUtils,
                    vsCode = options.vsCode,
                    fsCode = options.fsCode;

                this.vertices = new Float32Array([
                    -1.0,-1.0, 1.0,-1.0, -1.0,1.0,
                    1.0,-1.0, 1.0,1.0, -1.0,1.0
                ]);
                this.shader = shaderUtils.createProgram(this.gl, vsCode, fsCode);
                this.gl.enableVertexAttribArray(
                        this.gl.getAttribLocation(this.shader, "position"));
                this.texture = shaderUtils.createTexture(this.gl, options.image1);
                this.vertexBuffer = this.gl.createBuffer();
                this.startTime = new Date().getTime();
                this.trackMouse();
                this.gl.useProgram(this.shader);
                this.renderLoop();
            },

            trackMouse: function () {
                var mousePos = this.mousePos = {
                    x: this.viewportWidth/2,
                    y: this.viewportHeight/2
                };
                this.el.onmousemove = function (e) {
                    mousePos.x = e.clientX;
                    mousePos.y = e.clientY;
                };
            },

            render: function () {
                this.updateParticles();
                this.prepareShader();
                this.draw();
            },

            updateParticles: function () {
                var particles = this.particles,
                    numParticles = ~~(this.particles.length/NUM_PARTICLE_COMPONENTS);

                for (var i = 0; i < NUM_MAX_PARTICLES; i++) {
                    var life = particles[i*3+PARTICLE_LIFE] || 0;
                    if (life < 0) {
                        life++;
                    } else {
                        life -= .001*(i+1);
                        if (life < .01) {
                            life = -Math.random()*20;
                            particles[i*3+PARTICLE_X] = Math.random()*this.viewportWidth;
                            particles[i*3+PARTICLE_Y] = Math.random()*this.viewportHeight;
                        }
                    }
                    particles[i*3+PARTICLE_LIFE] = life;
                }
            },

            prepareShader: function () {
                var gl = this.gl,
                    shader = this.shader;

                gl.vertexAttribPointer(
                        gl.getAttribLocation(shader, "position"),
                        2, gl.FLOAT, false, 0, 0);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.uniform1i(uni("tex0"), 0);

                gl.uniform1f(uni("time"), (new Date().getTime()-this.startTime)/1000);
                gl.uniform2f(uni("resolution"), this.viewportWidth, this.viewportHeight);
                gl.uniform2f(uni("mouse"), this.mousePos.x, this.mousePos.y);
                gl.uniform2f(uni("lightDirection"), Math.sqrt(2), Math.sqrt(2));
                gl.uniform3fv(uni("particles"), this.particles);

                function uni (uniformName) {
                    return gl.getUniformLocation(shader, uniformName);
                }
            },

            draw: function () {
                var gl = this.gl;
                gl.viewport(0, 0, this.viewportWidth, this.viewportHeight);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, this.vertices.length/2);
            }
        };
    };

</script>


<script type="text/javascript">

/**
 * Initialize hook
 * ---------------
 *
 * This is simply the initialization code we will run after document as finished
 * loading. Mainly we just set up the demo instance and give it the necessary
 * argument, in order for it to do its job.
 *
 */
window.onload = function initialize () {
    var demo, image, canvas;

    // Create a canvas for ourselves.
    canvas = document.createElement('canvas');
    document.body.appendChild(canvas);

    // Point at which everything should be loaded and we can start the application.
    function start () {
        demo = new timotuominen.webgl.FromScratchDemo({
            image1: image,
            vsCode: document.getElementById("vs-shader").innerHTML,
            fsCode: document.getElementById("fs-shader").innerHTML,
            el: canvas
        });
        demo.initialize();

        window.onresize = updateCanvasSize;
        updateCanvasSize();
    }

    // Call this whenever there are changes in canvas size.
    function updateCanvasSize () {
        // Set the canvas size to match the window size. Notice that canvas.width and canvas.height are not the
        // same as the CSS width and height of the canvas! If you use CSS to size your canvas, you will always have
        // to manually set the properties width and height of the canvas element accordingly.
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Tell the demo that its canvas has changed its size.
        demo.updateSize();
    }

    // Create a simple image DOM element and tell it to load an image. When it is loaded, start!
    image = new Image();
    image.onload = start;
    image.src = "IMG_2235.JPG";
};

</script>

<script type="text/javascript">

/**
 * Basic renderer
 * --------------
 *
 * Another utility class; this time for initializing and continuously rendering the view. It tries to run at 60 fps,
 * and does not have any funny optimizations regarding this. In real life you may want to use the experimental feature
 * some browsers have, [requestAnimationFrame], or reduce fps in case the browser cannot handle it.
 *
 *  [requestAnimationFrame]: https://developer.mozilla.org/en/DOM/window.requestAnimationFrame
 *
 */
timotuominen.webgl.Runner = function (options) {
    options = options || {};
    return {

        // Hold the canvas element.
        el: options.el,

        // Initialize should be called to start the loop.
        initialize: function () {
            // First we create the WebGL object by requesting "experimental-webgl" context.
            // If WebGL is not supported, this will either throw an error or result null.
            // For this example we will not handle these scenarios.
            this.gl = this.el.getContext("experimental-webgl");

            this.updateSize = this.updateSize.bind(this);
            this.updateSize();

            // Color that is used to clear the whole canvas before starting to
            // draw the frame. We use rgba here, in which all four components
            // are from 0.0 to 1.0.
            this.gl.clearColor(0.3, 0.3, 0.3, 1.0);

            // Bind the renderLoop to this object. Since we will be using a timeout to
            // call renderLoop continually, it would otherwise be the window object.
            var realRenderLoop = this.renderLoop;
            var self = this;
            this.renderLoop = function () {
                realRenderLoop.apply(self);
            };
        },

        updateSize: function () {
            // Store the size of the canvas. DOM operation are in general expensive,
            // and we certainly don't want to do this on every frame.
            this.viewportWidth = this.el.width;
            this.viewportHeight = this.el.height;
        },

        // The rendering loop that repeatedly call itself 60 times a second.
        renderLoop: function() {
            setTimeout(this.renderLoop, 1000/60);
            this.render && this.render();
        }

    };
};

/**
 * Shader utilities
 * ----------------
 *
 * Unfortunately we have to prepare our shader with some boilerplate code, of which cannot really go around. Here is a
 * small utilities that help us to initialize the shaders. Usually this would be buried in some library code you are
 * using, but I find it helpful to see what is actually going on.
 *
 * Or, the very least, how much is going on.
 *
 */
timotuominen.webgl.shaderUtils = {

    // A shader program is basically vertex shader + fragment shader
    // compiled into a bytecode that the graphics card can execute.
    createProgram: function (gl, vsCode, fsCode) {
        var i, vs, fs, tmpProgram = gl.createProgram();
        try {
            vs = this.compileShader(gl, vsCode, gl.VERTEX_SHADER);
            fs = this.compileShader(gl, fsCode, gl.FRAGMENT_SHADER);
        } catch (e) {
            gl.deleteProgram( tmpProgram );
            throw e;
        }
        gl.attachShader(tmpProgram, vs);
        gl.deleteShader(vs);
        gl.attachShader(tmpProgram, fs);
        gl.deleteShader(fs);
        gl.linkProgram(tmpProgram);
        return tmpProgram;
    },

    // Compiles a single shader into bytecode.
    compileShader: function (gl, code, type) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw "SHADER ERROR: " + gl.getShaderInfoLog(shader);
        }
        return shader;
    },

    // Create a texture from a loaded Image. The image is simply a
    // reference to a DOM element, which has finished loading.
    createTexture: function (gl, image) {
        var texture = gl.createTexture();

        // Tell WebGL we want to load activate our texture.
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Set the texture to match our image. Understanding the magic is not
        // important, unless you know what you are doing with the image bytes.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        // Set the filters to use if the texture needs to be scaled up or down.
        // These are the simplest ones you would want to use, and work predictably.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        // What should happen if we run out of texture? CLAMP_TO_EDGE makes
        // WebGL repeat the edge pixels for the empty area.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        // We are ready, release the texture.
        gl.bindTexture(gl.TEXTURE_2D, null);

        // Return our processed texture.
        return texture;
    }
};

</script>

</head>
<body>
    <a href="../explain.html#particle_ripple" style="position:fixed;background:white;top:0;right:0;text-decoration:none;color:black;padding:5px 7px;border-bottom:2px solid black;border-left:2px solid black;">Show formatted source</a>
</body>
</html>