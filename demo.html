<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!--
<h1>WebGL standalone<br/>example</h1>

<p><i>The WebGL tutorial written from scratch&mdash;without any external libraries.
See the this demo <a href="demo.html">live</a></i></p>

<p>To directly tap into hardware acceleration, we need to setup a 3D rendering pipeline. Of course, we can still do 2D as
well by using planes, but the technology under the hood is for 3D.</p>

<p>To do this, we feed the graphics card specifically crafted pieces of code it can digest. These pieces are called

<b>shaders</b>. Shaders are always written in a special <a href="http://en.wikipedia.org/wiki/GLSL">shader language</a>.
It looks a bit like C, but with powerful syntax for processing structures with multiple components&mdash;such as colors.</p>

<p>So, what exactly happens when we render?</p>

<p>First, we are given a chance to manipulate our 3D model with a <b>vertex shader</b>. The name comes from the corners
of a model being called vertices (singular "vertex"). Most commonly you would apply a matrix transformation, or two, to
render your model in the correct place. You can read more about matrices in 3D programming from plenty of sources.</p>

<p>The second step we can do, is assigning a <b>fragment shader</b> (also sometimes referred to as a pixel shader).
A fragment shaders allows us to run the same code for every single pixel visible. The vertex shader can pass values to
the pixel shader, such as the current xy-position on the surface of the model being rendered. This way we can know which
pixel of the texture image to use when rendering.</p>

<p>You have to have both of these shaders, but fortunately the simplest form for each is only a few lines. In this
example the shader are embedded to the HTML page as script blocks of a specific type, but you could as well load them
from a text file with ajax, or to write them inline as a JavaScript string. WebGL will never know where the code came
from.</p>

<p>This example will be a single HTML page, with no external dependencies.<p>
-->
<html>
<head>
<title>WebGL from Scratch</title>

<style type="text/css">
    body {
        margin: 0;
        padding: 0;
    }
</style>

<!--
<h2>Vertex shader<br/>(operates on 3D models)</h2>
<p>Of our two shaders, let's start with the vertex shader, as it is processed first in the WebGL rendering chain.
Vertex shader is a function, which is executed on every vertex (corner point) of the 3D model being rendered. A vertex
goes in, and a modifies vertex comes out. This does not affect the original model, but is performed anew each time we
render.</p>

<p>Here you would do all kinds of transformations on the 3D model. Usually this would involve rotating and scaling the
model around its own origin, and then moving it to the correct position in the final 3D world. The matrix "transform"
contains all necessary information to do this. You can google more about matrix transformations, they are a heavily
covered topic in mathematics.</p>

<p>Notice that the type of the script block is arbitrary; it is treated as pure text.</p>
-->
<script id="vs-shader" type="x-shader/x-vertex">

    // Position on the surface of the model.
    attribute vec4 position;

    // Used to pass the xy-coordinate for the texture pixel.
    varying vec2 xyPos;

    // Matrix used for transformation (not required, just useful).
    uniform mat4 transform;

    // Entry point for shader is always the method main.
    // It does not return anything, nor does it take arguments.
    void main(void) {
        // Calculate the texture xy-coordinate, considering our surface is of size (1.0,1.0) with origin at (0.5,0.5).
        xyPos = vec2(position.x*.5+.5,.5-position.y*.5);
        // Assigning a value to gl_Position is this the vertex shader's way of returning a value.
        gl_Position = transform*position;
    }

</script>

<!--
<h2>Fragment shader<br/>(operates on pixels)</h2>

<p>If you are wondering about all the keywords, here is a quick list of what the ones before variables mean.</p>

<ul>
<li>attribute: a value WebGL gives to us.</li>
<li>varying: shader across shaders and can be modified.</li>
<li>uniform: assignable from <b>outside</b> of WebGL. In our case can be set from JS.</li>
</ul>
-->
<script id="fs-shader" type="x-shader/x-fragment">

    // Some boilerplate code; just include it.
    #ifdef GL_ES
    precision highp float;
    #endif

    // Value the vertex shader passes to us.
    varying vec2 xyPos;

    // Texture we want to use.
    uniform sampler2D tex;

    // Entry point of all shaders.
    void main(void) {
        // gl_FragColor is the return value. Simply read the pixel value of
        // our texture at coordinate xyPos.
        gl_FragColor = texture2D(tex, xyPos);
    }

</script>

<!--
<h2>The actual code for the demo</h2>
-->
<script type="text/javascript">

    // Namespace for the things we are creating.
    window.timotuominen = { webgl: {} };

    // The actual demo we will show.
    timotuominen.webgl.FromScratchDemo = function (options) {
        options = options || {};
        return {
            __proto__: new timotuominen.webgl.Runner(options),
            shader: null,
            vertexBuffer: null,
            texture: null,
            matrix: new Float32Array([
                1.,0.,0.,0.,
                0.,1.,0.,0.,
                0.,0.,1.,0.,
                0.,0.,0.,1.
            ]),
            vertices: new Float32Array([
                -1.0,-1.0, 1.0,-1.0, -1.0,1.0,
                1.0,-1.0, 1.0,1.0, -1.0,1.0
            ]),
            initialize: function () {
                var shaderUtils = timotuominen.webgl.shaderUtils,
                    vsCode = options.vsCode,
                    fsCode = options.fsCode;
                this.__proto__.initialize.apply(this);
                this.shader = shaderUtils.createProgram(this.gl, vsCode, fsCode);
                this.texture = shaderUtils.createTexture(this.gl, options.image1);
                this.vertexBuffer = this.gl.createBuffer();
            },
            render: function () {
                var gl = this.gl;
                gl.useProgram(this.shader);
                gl.uniformMatrix4fv(
                        gl.getUniformLocation(this.shader, "transform"),
                        false, this.matrix);
                gl.enableVertexAttribArray(
                        gl.getAttribLocation(this.shader, "position"));
                gl.vertexAttribPointer(
                        gl.getAttribLocation(this.shader, "position"),
                        2, gl.FLOAT, false, 0, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.uniform1i(gl.getUniformLocation(this.shader, "tex"), 0);
                gl.viewport(0, 0, this.viewportWidth, this.viewportHeight);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, this.vertices.length/2);
            }
        };
    };

</script>

<!--
<h2>Shader utilities</h2>

<p>Unfortunately we have to prepare our shader with some boilerplate code, of which cannot really go around. Here is a
small utilities that help us to initialize the shaders. Usually this would be buried in some library code you are
using, but I find it helpful to see what is actually going on.</p>

<p>Or, the very least, how much is going on.</p>
-->
<script type="text/javascript">

    // Utilities for WebGL shaders.
    timotuominen.webgl.shaderUtils = {

        // A shader program is basically vertex shader + fragment shader
        // compiled into a bytecode that the graphics card can execute.
        createProgram: function (gl, vsCode, fsCode) {
            var i, vs, fs, tmpProgram = gl.createProgram();
            try {
                vs = this.compileShader(gl, vsCode, gl.VERTEX_SHADER);
                fs = this.compileShader(gl, fsCode, gl.FRAGMENT_SHADER);
            } catch (e) {
                gl.deleteProgram( tmpProgram );
                throw e;
            }
            gl.attachShader(tmpProgram, vs);
            gl.deleteShader(vs);
            gl.attachShader(tmpProgram, fs);
            gl.deleteShader(fs);
            gl.linkProgram(tmpProgram);
            return tmpProgram;
        },

        // Compiles a single shader into bytecode.
        compileShader: function (gl, code, type) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw "SHADER ERROR: " + gl.getShaderInfoLog(shader);
            }
            return shader;
        },

        // Create a texture from a loaded Image. The image is simply a
        // reference to a DOM element, which has finished loading.
        createTexture: function (gl, image) {
            var texture = gl.createTexture();

            // Tell WebGL we want to load activate our texture.
            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Set the texture to match our image. Understanding the magic is not
            // important, unless you know what you are doing with the image bytes.
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            // Set the filters to use if the texture needs to be scaled up or down.
            // These are the simplest ones you would want to use, and work predictably.
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

            // What should happen if we run out of texture? CLAMP_TO_EDGE makes
            // WebGL repeat the edge pixels for the empty area.
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // We are ready, release the texture.
            gl.bindTexture(gl.TEXTURE_2D, null);

            // Return our processed texture.
            return texture;
        }
    };

</script>

<!--
<h2>Basic renderer</h2>

<p>Another utility class; this time for initializing and continuously rendering the view. It tries to run at 60 fps,
and does not have any funny optimizations regarding this. In real life you may want to use the experimental feature
some browsers have,
<a href="https://developer.mozilla.org/en/DOM/window.requestAnimationFrame">requestAnimationFrame</a>, or reduce fps
in case the browser cannot handle it.
-->
<script type="text/javascript">

    timotuominen.webgl.Runner = function (options) {
        options = options || {};
        var self = {

            // Hold the canvas element.
            el: options.el,

            // Initialize should be called to start the loop.
            initialize: function () {
                // First we create the WebGL object by requesting "experimental-webgl" context.
                // If WebGL is not supported, this will either throw an error or result null.
                // For this example we will not handle these scenarios.
                this.gl = this.el.getContext("experimental-webgl");

                // Store the size of the canvas. DOM operation are in general expensive,
                // and we certainly don't want to do this on every frame.
                this.viewportWidth = this.el.width;
                this.viewportHeight = this.el.height;

                // Color that is used to clear the whole canvas before starting to
                // draw the frame. We use rgba here, in which all four components
                // are from 0.0 to 1.0.
                this.gl.clearColor(0.3, 0.3, 0.3, 1.0);

                // Bind the renderLoop to this object. Since we will be using a timeout to
                // call renderLoop continually, it would otherwise be the window object.
                var realRenderLoop = this.renderLoop;
                var self = this;
                this.renderLoop = function () {
                    realRenderLoop.apply(self);
                };
            },

            // The rendering loop that repeatedly call itself 60 times a second.
            renderLoop: function() {
                setTimeout(this.renderLoop, 1000/60);
                this.render && this.render();
            }

        };
        return self;
    };

</script>

<!--
<h2>Initialize hook</h2>
-->
<script type="text/javascript">

    function initialize () {
        var demo, image, canvas;

        canvas = document.getElementById('canvas');

        // Set the canvas size to match the window size. Notice that canvas.width and canvas.height are not the
        // same as the CSS width and height of the canvas! If you use CSS to size your canvas, you will always have
        // to manually set the properties width and height of the canvas element accordingly.
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Point at which everything should be loaded and we can start the application.
        function start () {
            demo = new timotuominen.webgl.FromScratchDemo({
                image1: image,
                vsCode: document.getElementById("vs-shader").innerHTML,
                fsCode: document.getElementById("fs-shader").innerHTML,
                el: canvas
            });
            demo.initialize();
            demo.renderLoop();
        }

        // Create a simple image DOM element and tell it to load an image. When it is loaded, start!
        image = new Image();
        image.onload = start;
        image.src = "IMG_2235.JPG";
    }

</script>

<!--
<h3 style="text-align: center"><a href="demo.html">live version</a></h3>
-->
</head>
<body onload="initialize()">
    <canvas id="canvas"></canvas>
</body>
</html>