start 
  = __ program:Program __ { return program; }  

SourceCharacter 
  = .  

WhiteSpace "whitespace"
  = []  
  / Zs

LineTerminator 
  = []  

LineTerminatorSequence "end of line"
  = "\n"  
  / "\r\n"  
  / "\r"  
  / "\u2028"  
  / "\u2029"

Comment "comment"
  = MultiLineComment  
  / SingleLineComment

MultiLineComment 
  = "/*" ( ! "*/" SourceCharacter   )* "*/"  

MultiLineCommentNoLineTerminator 
  = "/*" ( ! ( "*/"  
  / LineTerminator ) SourceCharacter   )* "*/"  

SingleLineComment 
  = "//" ( ! LineTerminator SourceCharacter   )*  

Identifier "identifier"
  = ! ReservedWord name:IdentifierName { return name; }  

IdentifierName "identifier"
  = start:IdentifierStart parts:IdentifierPart* {
      return start + parts.join("");
    }  

IdentifierStart 
  = UnicodeLetter  
  / "$"  
  / "_"  
  / "\\" sequence:UnicodeEscapeSequence { return sequence; }

IdentifierPart 
  = IdentifierStart  
  / UnicodeCombiningMark  
  / UnicodeDigit  
  / UnicodeConnectorPunctuation  
  / "\u200C" { return "\u200C"; }  
  / "\u200D" { return "\u200D"; }

UnicodeLetter 
  = Lu  
  / Ll  
  / Lt  
  / Lm  
  / Lo  
  / Nl

UnicodeCombiningMark 
  = Mn  
  / Mc

UnicodeDigit 
  = Nd  

UnicodeConnectorPunctuation 
  = Pc  

ReservedWord 
  = Keyword  
  / FutureReservedWord  
  / NullLiteral  
  / BooleanLiteral

Keyword 
  = ( "break"  
  / "case"  
  / "catch"  
  / "continue"  
  / "debugger"  
  / "default"  
  / "delete"  
  / "do"  
  / "else"  
  / "finally"  
  / "for"  
  / "function"  
  / "if"  
  / "instanceof"  
  / "in"  
  / "new"  
  / "return"  
  / "switch"  
  / "this"  
  / "throw"  
  / "try"  
  / "typeof"  
  / "var"  
  / "void"  
  / "while"  
  / "with" ) ! IdentifierPart  

FutureReservedWord 
  = ( "class"  
  / "const"  
  / "enum"  
  / "export"  
  / "extends"  
  / "import"  
  / "super" ) ! IdentifierPart  

Literal 
  = NullLiteral  
  / BooleanLiteral  
  / value:NumericLiteral {
      return {
        type: "NumericLiteral",
        value: value
      };
    }  
  / value:StringLiteral {
      return {
        type: "StringLiteral",
        value: value
      };
    }  
  / RegularExpressionLiteral

NullLiteral 
  = NullToken { return { type: "NullLiteral" }; }  

BooleanLiteral 
  = TrueToken { return { type: "BooleanLiteral", value: true }; }  
  / FalseToken { return { type: "BooleanLiteral", value: false }; }

NumericLiteral "number"
  = literal:( HexIntegerLiteral  
  / DecimalLiteral ) ! IdentifierStart {
      return literal;
    }  

DecimalLiteral 
  = before:DecimalIntegerLiteral "." after:DecimalDigits? exponent:ExponentPart? {
      return parseFloat(before + "." + after + exponent);
    }  
  / "." after:DecimalDigits exponent:ExponentPart? {
      return parseFloat("." + after + exponent);
    }  
  / before:DecimalIntegerLiteral exponent:ExponentPart? {
      return parseFloat(before + exponent);
    }

DecimalIntegerLiteral 
  = "0"  
  / digit:NonZeroDigit digits:DecimalDigits? { return digit + digits; }

DecimalDigits 
  = digits:DecimalDigit+ { return digits.join(""); }  

DecimalDigit 
  = []  

NonZeroDigit 
  = []  

ExponentPart 
  = indicator:ExponentIndicator integer:SignedInteger {
      return indicator + integer;
    }  

ExponentIndicator 
  = []  

SignedInteger 
  = sign:[]? digits:DecimalDigits { return sign + digits; }  

HexIntegerLiteral 
  = "0" [] digits:HexDigit+ { return parseInt("0x" + digits.join("")); }  

HexDigit 
  = []  

StringLiteral "string"
  = parts:( '"' DoubleStringCharacters? '"'  
  / "'" SingleStringCharacters? "'" ) {
      return parts[1];
    }  

DoubleStringCharacters 
  = chars:DoubleStringCharacter+ { return chars.join(""); }  

SingleStringCharacters 
  = chars:SingleStringCharacter+ { return chars.join(""); }  

DoubleStringCharacter 
  = ! ( '"'  
  / "\\"  
  / LineTerminator ) char_:SourceCharacter { return char_; }  
  / "\\" sequence:EscapeSequence { return sequence; }  
  / LineContinuation

SingleStringCharacter 
  = ! ( "'"  
  / "\\"  
  / LineTerminator ) char_:SourceCharacter { return char_; }  
  / "\\" sequence:EscapeSequence { return sequence; }  
  / LineContinuation

LineContinuation 
  = "\\" sequence:LineTerminatorSequence { return sequence; }  

EscapeSequence 
  = CharacterEscapeSequence  
  / "0" ! DecimalDigit { return "\0"; }  
  / HexEscapeSequence  
  / UnicodeEscapeSequence

CharacterEscapeSequence 
  = SingleEscapeCharacter  
  / NonEscapeCharacter

SingleEscapeCharacter 
  = char_:[] {
      return char_
        .replace("b", "\b")
        .replace("f", "\f")
        .replace("n", "\n")
        .replace("r", "\r")
        .replace("t", "\t")
        .replace("v", "\x0B") // IE does not recognize "\v".
    }  

NonEscapeCharacter 
  = ( ! EscapeCharacter  
  / LineTerminator ) char_:SourceCharacter { return char_; }  

EscapeCharacter 
  = SingleEscapeCharacter  
  / DecimalDigit  
  / "x"  
  / "u"

HexEscapeSequence 
  = "x" h1:HexDigit h2:HexDigit {
      return String.fromCharCode(parseInt("0x" + h1 + h2));
    }  

UnicodeEscapeSequence 
  = "u" h1:HexDigit h2:HexDigit h3:HexDigit h4:HexDigit {
      return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
    }  

RegularExpressionLiteral "regular expression"
  = "/" body:RegularExpressionBody "/" flags:RegularExpressionFlags {
      return {
        type: "RegularExpressionLiteral",
        body: body,
        flags: flags
      };
    }  

RegularExpressionBody 
  = char_:RegularExpressionFirstChar chars:RegularExpressionChars {
      return char_ + chars;
    }  

RegularExpressionChars 
  = chars:RegularExpressionChar* { return chars.join(""); }  

RegularExpressionFirstChar 
  = ! [] char_:RegularExpressionNonTerminator { return char_; }  
  / RegularExpressionBackslashSequence  
  / RegularExpressionClass

RegularExpressionChar 
  = ! [] char_:RegularExpressionNonTerminator { return char_; }  
  / RegularExpressionBackslashSequence  
  / RegularExpressionClass

RegularExpressionBackslashSequence 
  = "\\" char_:RegularExpressionNonTerminator { return "\\" + char_; }  

RegularExpressionNonTerminator 
  = ! LineTerminator char_:SourceCharacter { return char_; }  

RegularExpressionClass 
  = "[" chars:RegularExpressionClassChars "]" { return "[" + chars + "]"; }  

RegularExpressionClassChars 
  = chars:RegularExpressionClassChar* { return chars.join(""); }  

RegularExpressionClassChar 
  = ! [] char_:RegularExpressionNonTerminator { return char_; }  
  / RegularExpressionBackslashSequence

RegularExpressionFlags 
  = parts:IdentifierPart* { return parts.join(""); }  

BreakToken 
  = "break" ! IdentifierPart  

CaseToken 
  = "case" ! IdentifierPart  

CatchToken 
  = "catch" ! IdentifierPart  

ContinueToken 
  = "continue" ! IdentifierPart  

DebuggerToken 
  = "debugger" ! IdentifierPart  

DefaultToken 
  = "default" ! IdentifierPart  

DeleteToken 
  = "delete" ! IdentifierPart { return "delete"; }  

DoToken 
  = "do" ! IdentifierPart  

ElseToken 
  = "else" ! IdentifierPart  

FalseToken 
  = "false" ! IdentifierPart  

FinallyToken 
  = "finally" ! IdentifierPart  

ForToken 
  = "for" ! IdentifierPart  

FunctionToken 
  = "function" ! IdentifierPart  

GetToken 
  = "get" ! IdentifierPart  

IfToken 
  = "if" ! IdentifierPart  

InstanceofToken 
  = "instanceof" ! IdentifierPart { return "instanceof"; }  

InToken 
  = "in" ! IdentifierPart { return "in"; }  

NewToken 
  = "new" ! IdentifierPart  

NullToken 
  = "null" ! IdentifierPart  

ReturnToken 
  = "return" ! IdentifierPart  

SetToken 
  = "set" ! IdentifierPart  

SwitchToken 
  = "switch" ! IdentifierPart  

ThisToken 
  = "this" ! IdentifierPart  

ThrowToken 
  = "throw" ! IdentifierPart  

TrueToken 
  = "true" ! IdentifierPart  

TryToken 
  = "try" ! IdentifierPart  

TypeofToken 
  = "typeof" ! IdentifierPart { return "typeof"; }  

VarToken 
  = "var" ! IdentifierPart  

VoidToken 
  = "void" ! IdentifierPart { return "void"; }  

WhileToken 
  = "while" ! IdentifierPart  

WithToken 
  = "with" ! IdentifierPart  

Ll 
  = []  

Lm 
  = []  

Lo 
  = []  

Lt 
  = []  

Lu 
  = []  

Mc 
  = []  

Mn 
  = []  

Nd 
  = []  

Nl 
  = []  

Pc 
  = []  

Zs 
  = []  

EOS 
  = __ ";"  
  / _ LineTerminatorSequence  
  / _ & "}"  
  / __ EOF

EOSNoLineTerminator 
  = _ ";"  
  / _ LineTerminatorSequence  
  / _ & "}"  
  / _ EOF

EOF 
  = ! .  

_ 
  = ( WhiteSpace  
  / MultiLineCommentNoLineTerminator  
  / SingleLineComment )*  

__ 
  = ( WhiteSpace  
  / LineTerminatorSequence  
  / Comment )*  

PrimaryExpression 
  = ThisToken { return { type: "This" }; }  
  / name:Identifier { return { type: "Variable", name: name }; }  
  / Literal  
  / ArrayLiteral  
  / ObjectLiteral  
  / "(" __ expression:Expression __ ")" { return expression; }

ArrayLiteral 
  = "[" __ elements:ElementList? __ ( Elision __   )? "]" {
      return {
        type: "ArrayLiteral",
        elements: elements !== "" ? elements : []
      };
    }  

ElementList 
  = ( Elision __   )? head:AssignmentExpression tail:( __ "," __ Elision? __ AssignmentExpression   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][5]);
      }
      return result;
    }  

Elision 
  = "," ( __ ","   )*  

ObjectLiteral 
  = "{" __ properties:( PropertyNameAndValueList __ ( "," __   )?   )? "}" {
      return {
        type: "ObjectLiteral",
        properties: properties !== "" ? properties[0] : []
      };
    }  

PropertyNameAndValueList 
  = head:PropertyAssignment tail:( __ "," __ PropertyAssignment   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][3]);
      }
      return result;
    }  

PropertyAssignment 
  = name:PropertyName __ ":" __ value:AssignmentExpression {
      return {
        type: "PropertyAssignment",
        name: name,
        value: value
      };
    }  
  / GetToken __ name:PropertyName __ "(" __ ")" __ "{" __ body:FunctionBody __ "}" {
      return {
        type: "GetterDefinition",
        name: name,
        body: body
      };
    }  
  / SetToken __ name:PropertyName __ "(" __ param:PropertySetParameterList __ ")" __ "{" __ body:FunctionBody __ "}" {
      return {
        type: "SetterDefinition",
        name: name,
        param: param,
        body: body
      };
    }

PropertyName 
  = IdentifierName  
  / StringLiteral  
  / NumericLiteral

PropertySetParameterList 
  = Identifier  

MemberExpression 
  = base:( PrimaryExpression  
  / FunctionExpression  
  / NewToken __ constructor:MemberExpression __ arguments:Arguments {
          return {
            type: "NewOperator",
            constructor: constructor,
            arguments: arguments
          };
        } ) accessors:( __ "[" __ name:Expression __ "]" { return name; }  
  / __ "." __ name:IdentifierName { return name; } )* {
      var result = base;
      for (var i = 0; i < accessors.length; i++) {
        result = {
          type: "PropertyAccess",
          base: result,
          name: accessors[i]
        };
      }
      return result;
    }  

NewExpression 
  = MemberExpression  
  / NewToken __ constructor:NewExpression {
      return {
        type: "NewOperator",
        constructor: constructor,
        arguments: []
      };
    }

CallExpression 
  = base:( name:MemberExpression __ arguments:Arguments {
        return {
          type: "FunctionCall",
          name: name,
          arguments: arguments
        };
      }   ) argumentsOrAccessors:( __ arguments:Arguments {
          return {
            type: "FunctionCallArguments",
            arguments: arguments
          };
        }  
  / __ "[" __ name:Expression __ "]" {
          return {
            type: "PropertyAccessProperty",
            name: name
          };
        }  
  / __ "." __ name:IdentifierName {
          return {
            type: "PropertyAccessProperty",
            name: name
          };
        } )* {
      var result = base;
      for (var i = 0; i < argumentsOrAccessors.length; i++) {
        switch (argumentsOrAccessors[i].type) {
          case "FunctionCallArguments":
            result = {
              type: "FuctionCall",
              name: result,
              arguments: argumentsOrAccessors[i].arguments
            };
            break;
          case "PropertyAccessProperty":
            result = {
              type: "PropertyAccess",
              base: result,
              name: argumentsOrAccessors[i].name
            };
            break;
          default:
            throw new Error(
              "Invalid expression type: " + argumentsOrAccessors[i].type
            );
        }
      }
      return result;
    }  

Arguments 
  = "(" __ arguments:ArgumentList? __ ")" {
    return arguments !== "" ? arguments : [];
  }  

ArgumentList 
  = head:AssignmentExpression tail:( __ "," __ AssignmentExpression   )* {
    var result = [head];
    for (var i = 0; i < tail.length; i++) {
      result.push(tail[i][3]);
    }
    return result;
  }  

LeftHandSideExpression 
  = CallExpression  
  / NewExpression

PostfixExpression 
  = expression:LeftHandSideExpression _ operator:PostfixOperator {
      return {
        type: "PostfixExpression",
        operator: operator,
        expression: expression
      };
    }  
  / LeftHandSideExpression

PostfixOperator 
  = "++"  
  / "--"

UnaryExpression 
  = PostfixExpression  
  / operator:UnaryOperator __ expression:UnaryExpression {
      return {
        type: "UnaryExpression",
        operator: operator,
        expression: expression
      };
    }

UnaryOperator 
  = DeleteToken  
  / VoidToken  
  / TypeofToken  
  / "++"  
  / "--"  
  / "+"  
  / "-"  
  / "~"  
  / "!"

MultiplicativeExpression 
  = head:UnaryExpression tail:( __ MultiplicativeOperator __ UnaryExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

MultiplicativeOperator 
  = operator:( "*"  
  / "/"  
  / "%" ) ! "=" { return operator; }  

AdditiveExpression 
  = head:MultiplicativeExpression tail:( __ AdditiveOperator __ MultiplicativeExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

AdditiveOperator 
  = "+" ! ( "+"  
  / "=" ) { return "+"; }  
  / "-" ! ( "-"  
  / "=" ) { return "-"; }

ShiftExpression 
  = head:AdditiveExpression tail:( __ ShiftOperator __ AdditiveExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

ShiftOperator 
  = "<<"  
  / ">>>"  
  / ">>"

RelationalExpression 
  = head:ShiftExpression tail:( __ RelationalOperator __ ShiftExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

RelationalOperator 
  = "<="  
  / ">="  
  / "<"  
  / ">"  
  / InstanceofToken  
  / InToken

RelationalExpressionNoIn 
  = head:ShiftExpression tail:( __ RelationalOperatorNoIn __ ShiftExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

RelationalOperatorNoIn 
  = "<="  
  / ">="  
  / "<"  
  / ">"  
  / InstanceofToken

EqualityExpression 
  = head:RelationalExpression tail:( __ EqualityOperator __ RelationalExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

EqualityExpressionNoIn 
  = head:RelationalExpressionNoIn tail:( __ EqualityOperator __ RelationalExpressionNoIn   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

EqualityOperator 
  = "==="  
  / "!=="  
  / "=="  
  / "!="

BitwiseANDExpression 
  = head:EqualityExpression tail:( __ BitwiseANDOperator __ EqualityExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

BitwiseANDExpressionNoIn 
  = head:EqualityExpressionNoIn tail:( __ BitwiseANDOperator __ EqualityExpressionNoIn   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

BitwiseANDOperator 
  = "&" ! ( "&"  
  / "=" ) { return "&"; }  

BitwiseXORExpression 
  = head:BitwiseANDExpression tail:( __ BitwiseXOROperator __ BitwiseANDExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

BitwiseXORExpressionNoIn 
  = head:BitwiseANDExpressionNoIn tail:( __ BitwiseXOROperator __ BitwiseANDExpressionNoIn   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

BitwiseXOROperator 
  = "^" ! ( "^"  
  / "=" ) { return "^"; }  

BitwiseORExpression 
  = head:BitwiseXORExpression tail:( __ BitwiseOROperator __ BitwiseXORExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

BitwiseORExpressionNoIn 
  = head:BitwiseXORExpressionNoIn tail:( __ BitwiseOROperator __ BitwiseXORExpressionNoIn   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

BitwiseOROperator 
  = "|" ! ( "|"  
  / "=" ) { return "|"; }  

LogicalANDExpression 
  = head:BitwiseORExpression tail:( __ LogicalANDOperator __ BitwiseORExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

LogicalANDExpressionNoIn 
  = head:BitwiseORExpressionNoIn tail:( __ LogicalANDOperator __ BitwiseORExpressionNoIn   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

LogicalANDOperator 
  = "&&" ! "=" { return "&&"; }  

LogicalORExpression 
  = head:LogicalANDExpression tail:( __ LogicalOROperator __ LogicalANDExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

LogicalORExpressionNoIn 
  = head:LogicalANDExpressionNoIn tail:( __ LogicalOROperator __ LogicalANDExpressionNoIn   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

LogicalOROperator 
  = "||" ! "=" { return "||"; }  

ConditionalExpression 
  = condition:LogicalORExpression __ "?" __ trueExpression:AssignmentExpression __ ":" __ falseExpression:AssignmentExpression {
      return {
        type: "ConditionalExpression",
        condition: condition,
        trueExpression: trueExpression,
        falseExpression: falseExpression
      };
    }  
  / LogicalORExpression

ConditionalExpressionNoIn 
  = condition:LogicalORExpressionNoIn __ "?" __ trueExpression:AssignmentExpressionNoIn __ ":" __ falseExpression:AssignmentExpressionNoIn {
      return {
        type: "ConditionalExpression",
        condition: condition,
        trueExpression: trueExpression,
        falseExpression: falseExpression
      };
    }  
  / LogicalORExpressionNoIn

AssignmentExpression 
  = left:LeftHandSideExpression __ operator:AssignmentOperator __ right:AssignmentExpression {
      return {
        type: "AssignmentExpression",
        operator: operator,
        left: left,
        right: right
      };
    }  
  / ConditionalExpression

AssignmentExpressionNoIn 
  = left:LeftHandSideExpression __ operator:AssignmentOperator __ right:AssignmentExpressionNoIn {
      return {
        type: "AssignmentExpression",
        operator: operator,
        left: left,
        right: right
      };
    }  
  / ConditionalExpressionNoIn

AssignmentOperator 
  = "=" ( ! "="   ) { return "="; }  
  / "*="  
  / "/="  
  / "%="  
  / "+="  
  / "-="  
  / "<<="  
  / ">>="  
  / ">>>="  
  / "&="  
  / "^="  
  / "|="

Expression 
  = head:AssignmentExpression tail:( __ "," __ AssignmentExpression   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

ExpressionNoIn 
  = head:AssignmentExpressionNoIn tail:( __ "," __ AssignmentExpressionNoIn   )* {
      var result = head;
      for (var i = 0; i < tail.length; i++) {
        result = {
          type: "BinaryExpression",
          operator: tail[i][1],
          left: result,
          right: tail[i][3]
        };
      }
      return result;
    }  

Statement 
  = Block  
  / VariableStatement  
  / EmptyStatement  
  / ExpressionStatement  
  / IfStatement  
  / IterationStatement  
  / ContinueStatement  
  / BreakStatement  
  / ReturnStatement  
  / WithStatement  
  / LabelledStatement  
  / SwitchStatement  
  / ThrowStatement  
  / TryStatement  
  / DebuggerStatement  
  / FunctionDeclaration  
  / FunctionExpression

Block 
  = "{" __ statements:( StatementList __   )? "}" {
      return {
        type: "Block",
        statements: statements !== "" ? statements[0] : []
      };
    }  

StatementList 
  = head:Statement tail:( __ Statement   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][1]);
      }
      return result;
    }  

VariableStatement 
  = VarToken __ declarations:VariableDeclarationList EOS {
      return {
        type: "VariableStatement",
        declarations: declarations
      };
    }  

VariableDeclarationList 
  = head:VariableDeclaration tail:( __ "," __ VariableDeclaration   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][3]);
      }
      return result;
    }  

VariableDeclarationListNoIn 
  = head:VariableDeclarationNoIn tail:( __ "," __ VariableDeclarationNoIn   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][3]);
      }
      return result;
    }  

VariableDeclaration 
  = name:Identifier __ value:Initialiser? {
      return {
        type: "VariableDeclaration",
        name: name,
        value: value !== "" ? value : null
      };
    }  

VariableDeclarationNoIn 
  = name:Identifier __ value:InitialiserNoIn? {
      return {
        type: "VariableDeclaration",
        name: name,
        value: value !== "" ? value : null
      };
    }  

Initialiser 
  = "=" ( ! "="   ) __ expression:AssignmentExpression { return expression; }  

InitialiserNoIn 
  = "=" ( ! "="   ) __ expression:AssignmentExpressionNoIn { return expression; }  

EmptyStatement 
  = ";" { return { type: "EmptyStatement" }; }  

ExpressionStatement 
  = ! ( "{"  
  / FunctionToken ) expression:Expression EOS { return expression; }  

IfStatement 
  = IfToken __ "(" __ condition:Expression __ ")" __ ifStatement:Statement elseStatement:( __ ElseToken __ Statement   )? {
      return {
        type: "IfStatement",
        condition: condition,
        ifStatement: ifStatement,
        elseStatement: elseStatement !== "" ? elseStatement[3] : null
      };
    }  

IterationStatement 
  = DoWhileStatement  
  / WhileStatement  
  / ForStatement  
  / ForInStatement

DoWhileStatement 
  = DoToken __ statement:Statement __ WhileToken __ "(" __ condition:Expression __ ")" EOS {
      return {
        type: "DoWhileStatement",
        condition: condition,
        statement: statement
      };
    }  

WhileStatement 
  = WhileToken __ "(" __ condition:Expression __ ")" __ statement:Statement {
      return {
        type: "WhileStatement",
        condition: condition,
        statement: statement
      };
    }  

ForStatement 
  = ForToken __ "(" __ initializer:( VarToken __ declarations:VariableDeclarationListNoIn {
          return {
            type: "VariableStatement",
            declarations: declarations
          };
        }  
  / ExpressionNoIn? ) __ ";" __ test:Expression? __ ";" __ counter:Expression? __ ")" __ statement:Statement {
      return {
        type: "ForStatement",
        initializer: initializer !== "" ? initializer : null,
        test: test !== "" ? test : null,
        counter: counter !== "" ? counter : null,
        statement: statement
      };
    }  

ForInStatement 
  = ForToken __ "(" __ iterator:( VarToken __ declaration:VariableDeclarationNoIn { return declaration; }  
  / LeftHandSideExpression ) __ InToken __ collection:Expression __ ")" __ statement:Statement {
      return {
        type: "ForInStatement",
        iterator: iterator,
        collection: collection,
        statement: statement
      };
    }  

ContinueStatement 
  = ContinueToken _ label:( identifier:Identifier EOS { return identifier; }  
  / EOSNoLineTerminator { return ""; } ) {
      return {
        type: "ContinueStatement",
        label: label !== "" ? label : null
      };
    }  

BreakStatement 
  = BreakToken _ label:( identifier:Identifier EOS { return identifier; }  
  / EOSNoLineTerminator { return ""; } ) {
      return {
        type: "BreakStatement",
        label: label !== "" ? label : null
      };
    }  

ReturnStatement 
  = ReturnToken _ value:( expression:Expression EOS { return expression; }  
  / EOSNoLineTerminator { return ""; } ) {
      return {
        type: "ReturnStatement",
        value: value !== "" ? value : null
      };
    }  

WithStatement 
  = WithToken __ "(" __ environment:Expression __ ")" __ statement:Statement {
      return {
        type: "WithStatement",
        environment: environment,
        statement: statement
      };
    }  

SwitchStatement 
  = SwitchToken __ "(" __ expression:Expression __ ")" __ clauses:CaseBlock {
      return {
        type: "SwitchStatement",
        expression: expression,
        clauses: clauses
      };
    }  

CaseBlock 
  = "{" __ before:CaseClauses? defaultAndAfter:( __ DefaultClause __ CaseClauses?   )? __ "}" {
      var before = before !== "" ? before : [];
      if (defaultAndAfter !== "") {
        var defaultClause = defaultAndAfter[1];
        var clausesAfter = defaultAndAfter[3] !== ""
          ? defaultAndAfter[3]
          : [];
      } else {
        var defaultClause = null;
        var clausesAfter = [];
      }

      return (defaultClause ? before.concat(defaultClause) : before).concat(clausesAfter);
    }  

CaseClauses 
  = head:CaseClause tail:( __ CaseClause   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][1]);
      }
      return result;
    }  

CaseClause 
  = CaseToken __ selector:Expression __ ":" statements:( __ StatementList   )? {
      return {
        type: "CaseClause",
        selector: selector,
        statements: statements !== "" ? statements[1] : []
      };
    }  

DefaultClause 
  = DefaultToken __ ":" statements:( __ StatementList   )? {
      return {
        type: "DefaultClause",
        statements: statements !== "" ? statements[1] : []
      };
    }  

LabelledStatement 
  = label:Identifier __ ":" __ statement:Statement {
      return {
        type: "LabelledStatement",
        label: label,
        statement: statement
      };
    }  

ThrowStatement 
  = ThrowToken _ exception:Expression EOSNoLineTerminator {
      return {
        type: "ThrowStatement",
        exception: exception
      };
    }  

TryStatement 
  = TryToken __ block:Block __ catch_:Catch __ finally_:Finally {
      return {
        type: "TryStatement",
        block: block,
        "catch": catch_,
        "finally": finally_
      };
    }  
  / TryToken __ block:Block __ catch_:Catch {
      return {
        type: "TryStatement",
        block: block,
        "catch": catch_,
        "finally": null
      };
    }  
  / TryToken __ block:Block __ finally_:Finally {
      return {
        type: "TryStatement",
        block: block,
        "catch": null,
        "finally": finally_
      };
    }

Catch 
  = CatchToken __ "(" __ identifier:Identifier __ ")" __ block:Block {
      return {
        type: "Catch",
        identifier: identifier,
        block: block
      };
    }  

Finally 
  = FinallyToken __ block:Block {
      return {
        type: "Finally",
        block: block
      };
    }  

DebuggerStatement 
  = DebuggerToken EOS { return { type: "DebuggerStatement" }; }  

FunctionDeclaration 
  = FunctionToken __ name:Identifier __ "(" __ params:FormalParameterList? __ ")" __ "{" __ elements:FunctionBody __ "}" {
      return {
        type: "Function",
        name: name,
        params: params !== "" ? params : [],
        elements: elements
      };
    }  

FunctionExpression 
  = FunctionToken __ name:Identifier? __ "(" __ params:FormalParameterList? __ ")" __ "{" __ elements:FunctionBody __ "}" {
      return {
        type: "Function",
        name: name !== "" ? name : null,
        params: params !== "" ? params : [],
        elements: elements
      };
    }  

FormalParameterList 
  = head:Identifier tail:( __ "," __ Identifier   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][3]);
      }
      return result;
    }  

FunctionBody 
  = elements:SourceElements? { return elements !== "" ? elements : []; }  

Program 
  = elements:SourceElements? {
      return {
        type: "Program",
        elements: elements !== "" ? elements : []
      };
    }  

SourceElements 
  = head:SourceElement tail:( __ SourceElement   )* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][1]);
      }
      return result;
    }  

SourceElement 
  = Statement  