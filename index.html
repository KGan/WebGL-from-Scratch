<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title></title>

    <style type="text/css">
        body {
            margin: 0;
            padding: 0;
        }
    </style>
    
    <script id="vs-shader" type="x-shader/x-vertex">
        attribute vec3 position;
        varying vec2 xyPos;

        void main(void) {
            xyPos = vec2(position.x*.5+.5,.5-position.y*.5);
            gl_Position = vec4(position, 1.0);
        }
    </script>
    <script id="fs-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif

        varying vec2 xyPos;
        uniform vec2 resolution;
        uniform sampler2D tex;

        void main(void) {
            gl_FragColor = texture2D(tex, xyPos);
        }
    </script>
    <script type="text/javascript">
        window.timotuominen = { webgl: {} };

        timotuominen.webgl.createRunner = function () {
            return {
                el: null,
                gl: null,
                isRunning: true,

                initialize: function () {
                    this.gl = this.el.getContext("experimental-webgl");
                    this.gl.viewportWidth = this.el.width;
                    this.gl.viewportHeight = this.el.height;
                    this.gl.clearColor(.3,.3,.3,1.0);
                    this.renderLoop = this.renderLoop.bind(this);
                },
                renderLoop: function() {
                    if(this.isRunning) {
                        setTimeout(this.renderLoop, 1000/60);
                    }
                    this.preRender && this.preRender();
                    this.render && this.render();
                    this.postRender && this.postRender();
                }
            };
        };

        timotuominen.webgl.shaderUtils = {
            createProgram: function (gl, vertexShaderCode, fragmentShaderCode) {
                var i, tmpProgram = gl.createProgram(), vertexShader, fragmentShader;
                try {
                    vs = this.compileShader(gl, vertexShaderCode, gl.VERTEX_SHADER);
                    fs = this.compileShader(gl, fragmentShaderCode, gl.FRAGMENT_SHADER);
                } catch (e) {
                    gl.deleteProgram( tmpProgram );
                    throw e;
                }
                gl.attachShader(tmpProgram, vs);
                gl.deleteShader(vs);
                gl.attachShader(tmpProgram, fs);
                gl.deleteShader(fs);
                gl.linkProgram(tmpProgram);
                return tmpProgram;
            },
            compileShader: function (gl, code, type) {
                var s = gl.createShader(type);
                gl.shaderSource(s, code);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                    throw "SHADER ERROR: " + gl.getShaderInfoLog(s);
                }
                return s;
            },
            createTexture: function (gl, image) {
                var texture = gl.createTexture();
                gl.enable(gl.TEXTURE_2D);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.bindTexture(gl.TEXTURE_2D, null);
                return texture;
            }
        };

        timotuominen.webgl.fromScratchDemo = {
            textures: {},
            vsCode: null,
            fsCode: null,

            run: function (el) {
                var runner, gl, shader, vertices, vertexBuffer, texture;

                runner = timotuominen.webgl.createRunner();
                
                runner.preRender = function () {
                    if (!shader) {
                        shader = timotuominen.webgl.shaderUtils.createProgram(
                                gl,
                                timotuominen.webgl.fromScratchDemo.vsCode,
                                timotuominen.webgl.fromScratchDemo.fsCode
                            );
                    }
                    if (!texture && timotuominen.webgl.fromScratchDemo.textures.photo) {
                        texture = timotuominen.webgl.shaderUtils.createTexture(this.gl, timotuominen.webgl.fromScratchDemo.textures.photo);
                    }
                    if (!vertexBuffer) {
                        vertices = new Float32Array([ -1.0,-1.0, 1.0,-1.0, -1.0,1.0, 1.0,-1.0, 1.0,1.0, -1.0,1.0]);
                        vertexBuffer = gl.createBuffer();
                        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                    }
                    if (shader) {
                        gl.useProgram(shader);
                        gl.uniform2f(gl.getUniformLocation(shader, "resolution"), gl.viewportWidth, gl.viewportHeight);
                        gl.enableVertexAttribArray(gl.getAttribLocation(shader, "position"));
                        gl.vertexAttribPointer(gl.getAttribLocation(shader, "position"), 2, gl.FLOAT, false, 0, 0);
                        if (texture) {
                            gl.activeTexture(gl.TEXTURE0);
                            gl.bindTexture(gl.TEXTURE_2D, texture);
                            gl.uniform1i(gl.getUniformLocation(this.shader, "tex"), 0);
                        }
                    }
                };

                runner.render = function () {
                    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    if (vertices && vertexBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                        gl.drawArrays(gl.TRIANGLES, 0, vertices.length/2);
                    }
                };

                el.width = window.innerWidth;
                el.height = window.innerHeight;
                runner.el = el;

                runner.initialize();

                gl = runner.gl;

                runner.renderLoop();
            }
        };

        function initialize () {
            var image, canvas;

            image = new Image();
            image.onload = function () {
                timotuominen.webgl.fromScratchDemo.textures.photo = image;
            };
            image.src = "IMG_2235.JPG";

            timotuominen.webgl.fromScratchDemo.vsCode = document.getElementById("vs-shader").innerHTML;
            timotuominen.webgl.fromScratchDemo.fsCode = document.getElementById("fs-shader").innerHTML;

            canvas = document.getElementById('canvas'),
            timotuominen.webgl.fromScratchDemo.run(canvas)
        }
    </script>
</head>
<body onload="initialize()">
    <canvas id="canvas"></canvas>
</body>
</html>